#----------------------------------------------------------
# TUYA WOOD PELLET STOVE Converted to ESP32
# version; 3.0.0
# date: 03-16-23
# 3.0 converted to ESP32, added realtime exhaust sensor
# 2.0 added fire stoking function
# 1.0.0 added a Power Level P5 (ultra low power) that is fully configurable while in ECO2 mode.
# 1.1.0 added echo of actual display messages and status via Display's MCU UART monitoring
#
# All of these mods give a new "Ultra Low" power level which turns down the heat during idle mode so the stove goes thru fewer (no)
# on/off/igniter cycles and just maintains a lower heat output (for smaller rooms)
# when the room cools enuf, ECO2 mode will kick back to "Heating" which
# turns off this new Ultra Low power level, then once the room temp is +2F above set temp, stove
# goes into "Idle" mode again and new Ultra Low is active again.  The cycle repeats and the stove stays lit.
# and room doesn't drastically heat up driving your wife nuts.
# These mods ***require*** replacing the Tuya chip with an ESP32 D1 Mini & some MCU control board and Display board mods.  
# See Github Discussions for complete details
#
# NOTE: I am NOT a career/pro programmer.  There is probably tons of opportunity to
# consolidate many of the if/then statements that check things into convoluted programmer-porn style 
# Lambda evaluations, but I hate writing and debugging Lambdas,
# so my code makes way more sense for the average person and is very easy to debug. 
# Your mileage may vary. 
# And, more inportant, it gets the job done!
#----------------------------------------
#
substitutions:
  device_name: "house-wood-pellet-stove"
  device_description: House Wood Pellet Stove running ESPHome
  friendly_name: House Wood Pellet Stove
  location: House
  lighting_count: "45" #sets max number of dumps of pellets during lighting
#----------------------------------------------------------
#
# only needed if u get compile errors. fixes "use F in Tuya Climate" for USA stoves set to Farenheight on the display unit
external_components:
  - source: github://pr#4032
    components: tuya
    refresh: 0s
#
esp32:
  board: wemos_d1_mini32
#
# define 3 hardware UARTS, 1 for TuyaMCU, others for MCU Display & temps monitoring
#
uart: 
#communication from TuyaMCU to tywe1s chip UART1
  - id: tywe1s_uart
    rx_pin: RX # Receives data from MCU, RX label on ESP32
    tx_pin: TX # Transmits data to MCU, TX label on ESP32
    baud_rate: 9600
#Display message decoding UART2
  - id: mcu_uart_TXpin
    rx_pin: GPIO16 #attach new wire to TX labled pin on DISPLAY board
    baud_rate: 2400
    rx_buffer_size: 80
    debug:
      direction: RX
      dummy_receiver: true
      after:
        delimiter: [0xCC, 0x33]
      sequence:
        - lambda: |-
            UARTDebug::log_hex(direction, bytes, ' ');             
            //Still log the data     
            //Some packets have 5 bytes  
            //might have to make this 3 if delimitar bytes get removed....
            if (bytes.size()==5) {
                if(bytes[0]==0xAA && bytes[1]==0x00) {
                //id(MCUrawString).publish_state("Heartbeat");
                //4B heartbeat, ignore
                if(bytes[2]==0x20)
                  id(MCUrawString).publish_state("Welcome to use");    
                if(bytes[2]==0x6A)
                  id(MCUrawString).publish_state("Goodbye!");              
                if(bytes[2]==0x69)
                  id(MCUrawString).publish_state("Cleaning");
                if(bytes[2]==0x63)
                  id(MCUrawString).publish_state("Cleaning");
                if(bytes[2]==0x65)
                  id(MCUrawString).publish_state("Lighting");
                if(bytes[2]==0x66)
                  id(MCUrawString).publish_state("Stabilization");
                if(bytes[2]==0x62)
                  id(MCUrawString).publish_state("Switching OFF");
                if(bytes[2]==0x69) 
                  id(MCUrawString).publish_state("Cooling");                                 
              }              
            }
            //Some packets have 6 bytes
            if (bytes.size()==6) {
              if(bytes[1]==0x01 && bytes[2]==0x46 && bytes[3]==0x02) 
                id(MCUrawString).publish_state("Welcome to use"); 
                //AA:00:59:CC:33
              if(bytes[1]==0x01 && bytes[2]==0x46 && bytes[3]==0x02) 
                id(MCUrawString).publish_state("Switching off");                 
              if(bytes[1]==0x01 && bytes[2]==0x49 && bytes[3]==0x80) 
                id(MCUrawString).publish_state("Stabilization"); 
              if(bytes[1]==0x01 && bytes[2]==0x49 && bytes[3]==0x00) 
                id(MCUrawString).publish_state("Stabilization"); 
              if(bytes[1]==0x01 && bytes[2]==0x49 && bytes[3]==0x81) 
                id(MCUrawString).publish_state("ECO2"); 
              if(bytes[1]==0x01 && bytes[2]==0x48 && bytes[3]==0x80) 
                id(MCUrawString).publish_state("ECO1"); 
              if(bytes[1]==0x01 && bytes[2]==0x48 && bytes[3]==0xC0) 
                id(MCUrawString).publish_state("Idling - ECO2"); 
              if(bytes[1]==0x01 && bytes[2]==0x49 && bytes[3]==0x01) 
                id(MCUrawString).publish_state("Idling - ECO2"); 
              if(bytes[1]==0x01 && bytes[2]==0x48 && bytes[3]==0x83) 
                id(MCUrawString).publish_state("ECO1"); 
              if(bytes[1]==0x01 && bytes[2]==0x48 && bytes[3]==0xC3) 
                id(MCUrawString).publish_state("ECO2"); 
              if(bytes[1]==0x01 && bytes[2]==0x49 && bytes[3]==0x81) 
                id(MCUrawString).publish_state("Idling - ECO2");  
            }
#from Display control board RX pin to MCU board RX pin UART3
#gives us real time pipe temps
  - id: mcu_uart_RXpin
    rx_pin: GPIO21 #attach new wire to RX labled pin on DISPLAY board
    baud_rate: 2400
    rx_buffer_size: 80
    debug:
      direction: RX
      dummy_receiver: true
      after:
        delimiter: [0xCC, 0x33]
      sequence:
        - lambda: |-
            UARTDebug::log_hex(direction, bytes, ' ');  
            //Still log the data     
            //Some packets have 5 bytes  
            //the full string-> the 7th HEX has the value I want(B8): AA:05:4B:00:00:26:B8:26:CC:33
            if (bytes.size()==10) {               
                // works up to approx 275 then it goes wonky somehow needing -72 instead of -36
                //but who cares, we only need stable values to stoke the fire
                id(pipe_converted).publish_state(((bytes[6]) * 1.8) - 4.0);          
                  }     
              
# #
globals:
  - id: auger_count_global
    type: int
    restore_value: no
    initial_value: '0'
  - id: stoking_flag_global
    type: bool
    initial_value: "false"
    restore_value: no
  - id: power_select_lastvalue
    type: int
    restore_value: yes
  - id: stoking_on_time_lastvalue
    type: int
    restore_value: yes
#
esphome:  
  name: ${device_name}
  platformio_options:
    upload_speed: 115200
    #REQUIRED FOR UART TO WORK
    board_build.extra_flags:
      - "-DARDUINO_USB_CDC_ON_BOOT=0"  # Override, defaults to '-DARDUINO_USB_CDC_ON_BOOT=1'
  comment: ${device_description}
  #platform: ESP8266
  #board: d1_mini #esp01_1m
  on_shutdown: 
    priority: 1000
    then:
    - switch.turn_off: auger_output_to_optoisolator
  on_boot:
    priority: -100
    then:
      - switch.turn_off: auger_output_to_optoisolator
      - delay: 5s
      - switch.turn_off: auger_output_to_optoisolator      
      - lambda: id(MCUrawString).publish_state("Initializing...");            
      - delay: 30s
      - logger.log: ".No executing on_boot. 30s delay over, STARTING UP"
      - switch.turn_off: auger_output_to_optoisolator
      - select.set_index:
          id: power_select
          index: !lambda return id(power_select_lastvalue);
          #set to saved flash value
      - if:
          condition:
            and:
            - text_sensor.state: #Stove is IDLING, not HEATING
                id: hvac_action
                state: 'idle'
            - sensor.in_range: #stove is lit
                id: stove_pipe_temp
                above: 125.0  
            - sensor.in_range: #stove is lit
                id: stove_pipe_temp
                below: 140.0       # exactly the point it switches           
          then: #sometimes display gets confused when esp randomly reboots
            - lambda: id(MCUrawString).publish_state("Idling - ECO2");
      - if:
          condition:
             - sensor.in_range: #stove is lit
                id: stove_pipe_temp
                above: 140.0 # exactly the point it switches 
          then:
             - lambda: id(MCUrawString).publish_state("Stabilization");          
          else:
              #- lambda: id(MCUrawString).publish_state("Initializing...");           
      - globals.set:
          id: stoking_flag_global
          value: 'false'             
      - if:
          condition: 
            - binary_sensor.is_on: p5z
          then:
            - switch.turn_on: p5_indicator
            - script.execute: new_auger_motor_power_level            
          else:  
            - switch.turn_off: p5_indicator
api:
  reboot_timeout: 0s # disabled so if we lose home assistant keep running
#
script:
  - id: stoke_fire
#started by on_value, 
#if burnpot is starting to go out, then rekindle it
    mode: single
    then:                      
#    - logger.log: #"script.stoke_fire. ENTERING"
#        format: "dp108.on_value.ABOUT TO TEST LAMBDA |stoking_temp= %f"
#        args: ['id(stoking_temp).state'] 
    - delay: 1s   #prevents race condition
    - while:
        condition:
          and:
            - lambda: return id(stoking_flag);
            - lambda: return id(tuya_climate);  # make sure stove is ON
            - text_sensor.state: #Stove is IDLING, not HEATING
                id: hvac_action
                state: 'idle'      
            - sensor.in_range: #**** Stove is NOT lighting
                id: stove_pipe_temp
                above: 125.0                                    
        then: # STOKE the fire to avoid E1 Error "fire went out"
            #might need to kick up P level so fan blows faster
            # - logger.log: 
            #     format: "SCRIPT.STOKING.Stoking FIRE | stoking_temp= %f"
            #     args: ['id(stoking_temp).state']               
            - switch.turn_on: auger_output_to_optoisolator  
            # - logger.log: "SCRIPT.STOKER.AUGER TURNING"  
            # - logger.log: 
            #     format: "SCRIPT.STOKING.Stoking FIRE | stoking_on_time= %f"
            #     args: ['id(stoking_on_time).state']              
            - delay: !lambda "return id(stoking_on_time).state * 1000;" # SECONDS ON
            - switch.turn_off: auger_output_to_optoisolator    
            - delay: !lambda "return id(stoking_off_time).state * 1000;" # SECONDS OFF 
    #go back to idle when done stoking
    - script.execute: new_auger_motor_power_level
#
#SCRIPT New P5 Power level Auger motor control      
#Started by the following events: p5z, on_boot, MCUrawString
#
  - id: new_auger_motor_power_level
    mode: single
    then:
#    - logger.log: "1script.new_auger_motor_power_level.STARTING"
#Main loop       
    - while:
        condition:
          and:
            - text_sensor.state: #Stove is idling in ECO2 mode
                id: hvac_action
                state: 'idle'
            - binary_sensor.is_on: p5z #We ARE In power level 5
            - binary_sensor.is_off: stoking_flag #we arent stoking the fire
            - lambda: return id(MCUrawString).state != "Cleaning";
        then:      
#          - logger.log: "1script.new_auger_motor_power_level.ENTERING WHILE"        
#new P5 Auger routine             
          - if:
              condition:
                - sensor.in_range: #**** Stove is lighting, exhaust is cold
                    id: stove_pipe_temp
                    below: 140          
              then:
#                - logger.log: "2script.new_auger_motor_power_level.STOPPING SCRIPT, pipe temp < 140"
                - script.stop: new_auger_motor_power_level
          - switch.turn_on: auger_output_to_optoisolator    
          - delay: !lambda "return id(auger_on_timez).state * 1000;"
#          - logger.log: "3script.newP5 active. Auger ON delay completed" 
          - switch.turn_off: auger_output_to_optoisolator  
          - delay: !lambda "return id(auger_off_timez).state * 1000;"
          # - logger.log: "4script.newP5 active. Auger OFF delay completed" 
          # - logger.log: "1script.new_auger_motor_power_level.EXITING WHILE"                  
    #ENDWHILE
#
binary_sensor:
  - platform: template # template sensors expose sensors to HA
    name: ${location} Stoke Fire Flag
    id: stoking_flag
    # set it to the value of the global
    lambda: |-
      if (id(stoking_flag_global) == 1) {
        return true;
      } else {
        return false;
      }
#read new P5 power mode from home assistant, toggle repurposed Timer LED on display module 
  - platform: homeassistant
    id: p5z
    entity_id: input_boolean.${location}_p5
    on_state:      
      then:
        # - logger.log: "logger: P5 button changed"       
        - if:
            condition:
              - binary_sensor.is_on: p5z #p5 is  active                      
            then:
              - logger.log: "script.P5 sw = TRUE turning ON P5 indicator"
              - switch.turn_on: p5_indicator
              - script.execute: new_auger_motor_power_level                               
            else: 
              # - logger.log: "script.p5z  = FALSE, turning OFF P5 indicator"            
              - switch.turn_off: p5_indicator    
        - if:
            condition:
              switch.is_on: p5_indicator   
            then:
              - logger.log: "GPIO16 sw = ON"
            else:
              - logger.log: "GPIO16 sw = OFF"                                    
#
    #MCU CONTROL BOARD AUGER SENSOR    
  - platform: gpio
    pin: GPIO27  # input only pin
    internal: false # this is just a flag you expose and watch in Lovelace
    id: ${location}_auger_sensor_from_mcu
    name: "${location} Auger Sensor from MCU" #Auger signal from MCU, goes low when Auger motor is running
    filters:
      - invert #flip it
    on_state: 
      then: 
        # - logger.log: "GPIOI18.Auger.from.MCU.on_state just changed"
        - if:
            condition:
              - binary_sensor.is_off: ${location}_auger_sensor_from_mcu
            then:
  #ECHO Auger  
        - if: #Stove is HEATING not IDLING
            condition:
              and:
                - binary_sensor.is_off: ${location}_auger_sensor_from_mcu
                - text_sensor.state: 
                    id: hvac_action
                    state: 'heating'         
            then:
              - switch.turn_off: auger_output_to_optoisolator
        - if: #LIGHTING, echo Auger
            condition:
              and:
                - binary_sensor.is_off: ${location}_auger_sensor_from_mcu
                - text_sensor.state:
                    id: MCUrawString
                    state: 'Lighting' 
            then:
              # - logger.log: "GPIOI12.Auger.from.MCU.Lighting"
              - switch.turn_off: auger_output_to_optoisolator
        - if: #HEATING (Stabilization), ECHO Auger
            condition:
              and:
                - binary_sensor.is_on: ${location}_auger_sensor_from_mcu
                - text_sensor.state: #Stove is HEATING, not IDLING
                    id: hvac_action
                    state: 'heating'    
            then:
  #ECHO Auger                    
              - switch.turn_on: auger_output_to_optoisolator  
              # - logger.log: "1GPIO18.AUGER TURNING"
        - if: #LIGHTING, ECHO Auger
            condition:
              and:
                - binary_sensor.is_on: ${location}_auger_sensor_from_mcu
                - text_sensor.state:
                    id: MCUrawString
                    state: 'Lighting' 
        #limit pellets in hopper on lighting. it only needs 35 turns to actually light. 
        #adjust this value if stove repeatedly fails to light every other time. 
                - lambda: |-
                    if (id(auger_count_global) <= ${lighting_count}) {      
                      return true; } 
                    else { 
                        return false;
                      } 
            then:
              - switch.turn_on: auger_output_to_optoisolator
              # - logger.log: "2GPIO12.AUGER TURNING"
              - lambda: id(auger_count_global) += 1; #keep track of how many auger turns happen and reset if stove lights
              - lambda: id(auger_counter).publish_state(id(auger_count_global)); #publish it to the sensor
        - if:
            condition:
              and:
                - binary_sensor.is_off: p5z #NOT In power level 5
                - binary_sensor.is_on: ${location}_auger_sensor_from_mcu  
            then:
                - switch.turn_on: auger_output_to_optoisolator
                # - logger.log: "3GPIO18.AUGER TURNING"
        - if:
            condition:
              and:
                - binary_sensor.is_off: p5z #NOT In power level 5
                - binary_sensor.is_off: ${location}_auger_sensor_from_mcu              
            then:
              - switch.turn_off: auger_output_to_optoisolator
button:
  - platform: restart #allows remote reset of tywe1s chip from home assistant or internally
    id: restart_esp
    name: "${location} Stove Restart" 
  - platform: safe_mode # required to upload firmware if were low on memory. put chip in safe mode, reboot, then OTA upload new firmware.
    name: "${location} SAFE Mode BUTTON"        
#
# DEFINE ALL SENSORS AND SWITCHES
#
text_sensor:
  - platform: debug
    device:
      name: "${location} Device Info"
    reset_reason:
      name: "${location} Reset Reason"
#from MCU in the display board, gives us what specific text is shown on the display
  - platform: template
    id: MCUrawString
    name: ${location}_display_text_sensor
    on_value:   # When value simply changes
      # - logger.log: "0MCUrawString.on_value.entered"    
      - delay: 0.1s
      #- switch.turn_off: auger_output_to_optoisolator # just to be safe
      - if:
          condition:
  #           and:
              - binary_sensor.is_on: p5z
             # - lambda: return id(MCUrawString).state == "Idling - ECO2";
              - text_sensor.state: #Stove is idling in ECO2 mode
                  id: hvac_action
                  state: 'idle'
          then: 
            # - logger.log: "1MCUrawString.new_auger_motor_power_level.CALLING SCRIPT"        
            - script.execute: new_auger_motor_power_level         
          else: #failsafe action
            # - logger.log: "2MCUrawString.new_auger_motor_power_level.STOPPING SCRIPT"              
            - script.stop: new_auger_motor_power_level
      - if: #keep track of how many auger turns happen during Lighting 
              #reset as soon as stove starts to light
              #and interrupt it in 'echo auger' at just the right level to avoid ESC1 errors from too much fuel in pot and stove burningbto hot on startup
          condition: #OR
              - lambda: return id(MCUrawString).state == "Stabilization";
              - lambda: return id(MCUrawString).state == "Idling - ECO2";
          then:
            - logger.log: "3MCUrawString.new_auger_motor_power_level.RESETTING AUGER COUNT = 0"
            - lambda: id(auger_count_global) = 0;
            - lambda: id(auger_counter).publish_state(id(auger_count_global));
#
  - platform: template
    name: "${location} Uptime (formatted)"
    lambda: |-
      uint32_t dur = id(uptime_s).state;
      int dys = dur / 86400;
      dur %= 86400;
      int hrs = dur / 3600;
      dur %= 3600;
      int mnts = dur / 60;
      dur %= 60;
      return str_sprintf("%ud %02uh %02um %02us", dys, hrs, mnts, dur);
    icon: mdi:clock-start
    update_interval: 10s
#get these object values from home assistant 
  - platform: homeassistant
    id: hvac_action
    entity_id: climate.${location}_wood_pellet_stove
#this sensor changes from HEATING to IDLE in ECO2 mode or when we reach set temp in ECO1.  
    attribute: hvac_action
    on_value:
      - if:
          condition:
  #           and:
              - text_sensor.state: #Stove is idling in ECO2 mode
                  id: hvac_action
                  state: 'idle'
          then: 
            - lambda: id(MCUrawString).publish_state("ECO2 - Idling");
            - script.execute: new_auger_motor_power_level        
      - if:
          condition:
  #           and:
              - text_sensor.state: #Stove is heating in ECO2 mode
                  id: hvac_action
                  state: 'heating'
          then: 
            - lambda: id(MCUrawString).publish_state("Stabilazation");
            - script.stop: new_auger_motor_power_level      
#
i2c:
  sda: 5
  scl: 33

sensor:  
#debug info   
  - platform: wifi_signal
    name: "${location} WiFi Signal db"
    update_interval: 10s 
    id: wifi_signal_db 
  - platform: copy # Reports the WiFi signal strength in %
    source_id: wifi_signal_db
    name: "${location} WiFi Signal %"
    filters:
      - lambda: return min(max(2 * (x + 100.0), 0.0), 100.0);
    unit_of_measurement: "Signal %"
    entity_category: "diagnostic"        
  - platform: debug
    free:
      name: "${location} Heap Free"
    
  - platform: template
    id: pipe_converted
    name: "${location} UART Pipe Temp"
    on_value:   # When value simply changes
      then:     
        - logger.log:
            format: "pipe_converted= %f"
            args: ['x']    
            #args: ['id(pipe_converted)']    
        - if:
            condition:
              and:
                - lambda: return id(MCUrawString).state != "Switching OFF";
                - lambda: return id(MCUrawString).state != "Lighting";
                - sensor.in_range: 
                      id: pipe_converted
                      above: 135.0                  
                - binary_sensor.is_on: p5z
                #Adjust the stoking_temp value in HA to keep pot from burning out
                - lambda: |-
                    if (id(pipe_converted).state <= id(stoking_temp).state) {
                      return true;
                    } else {
                      return false;
                    }
            then:  
              - logger.log: 
                  format: "dp108.on_value.EXECUTING SCRIPT Stoking FIRE | stoking_temp= %f"
                  args: ['id(stoking_temp).state']
              - globals.set: #expose to ha
                    id: stoking_flag_global
                    value: 'true'     
              - script.stop: new_auger_motor_power_level                                     
              - script.execute: stoke_fire
            else:
              - globals.set: #expose to ha
                  id: stoking_flag_global
                  value: 'false'    
              - script.stop: stoke_fire
              - script.execute: new_auger_motor_power_level 
                              

  - platform: template
    name: ${location} Auger Counter (lighting)
    id: auger_counter
    # do this whereever you want it to report back into HA's sensor value
    #   - lambda: id(auger_counter).publish_state(id(auger_count_global));
    
#get these object values from home assistant 
  - platform: homeassistant
    id: auger_off_timez
    entity_id: input_number.${location}_auger_off_time #helper in home assistant
#
  - platform: homeassistant
    id: auger_on_timez
    entity_id: input_number.${location}_auger_on_time #helper in home assistant
    
  - platform: homeassistant
    id: stoking_temp
    entity_id: input_number.${location}_stoking_temp #helper in home assistant
    force_update: true

  - platform: homeassistant
    id: stoking_on_time
    entity_id: input_number.${location}_stoking_on_time #helper in home assistant
    force_update: true

  - platform: homeassistant
    id: stoking_off_time
    entity_id: input_number.${location}_stoking_off_time #helper in home assistant
    force_update: true
#    
  - platform: vl53l0x  # <- MUCH more accurate and less noise than Ultrasonic sensors!
    name: "${location} raw pellet level"
    address: 0x29
    long_range: true
    timeout: 200us
    update_interval: 500ms
    unit_of_measurement: "m"
    accuracy_decimals: 2
    on_value:
      then:
# Replace 0.4 by the height of hopper. From the sensor to the bottom.
# website to know how to multiply values :https://www.skillsyouneed.com/num/percent-change.html 
        - sensor.template.publish:
            id: ultrasonic_smoothed
            state: !lambda 'return (0.4-x)*(100/0.4);'
# 
  - platform: template
    id: ultrasonic_smoothed
    update_interval: 30s    
    accuracy_decimals: 0     
    unit_of_measurement: "%"
    icon: "mdi:sack-percent"    
    name: "${location} pellet level processed & filtered"
    filters:
      - sliding_window_moving_average:
          window_size: 60
          send_every: 15
  #
  - platform: "tuya"
    name: "${location} Stove-Power On"
    sensor_datapoint: 1
    id: stove_on
#
  - platform: "tuya"
    name: "${location} Stove-Error Code"
    id: error_code
    sensor_datapoint: 104
  - platform: "tuya"
    name: "${location} Stove-Power Mode"
    sensor_datapoint: 4
  - platform: "tuya"
    name: "${location} Stove-Set Temp"
    sensor_datapoint: 106
  - platform: "tuya"
    id: current_temp
    name: "${location} Stove-Current Temp"
    sensor_datapoint: 107
  - platform: "tuya"
    name: "${location} Stove-Pipe Temp"
    id: stove_pipe_temp
    sensor_datapoint: 108
# #                               
  - platform: "tuya"
    name: "${location} Stove-Protect Temp"
    sensor_datapoint: 109
#more utility sensors
  - platform: uptime
    internal: false
    name: ${friendly_name} Uptime
    id: uptime_s
    update_interval: 10s
#
#DEFINE SELECTS
#
select:
  - platform: "tuya"
    tuya_id: "${location}"
    name: "${location} Power Select"
    id: power_select
    enum_datapoint: 4
    options:
      0: P1-High
      1: P2-Med High
      2: P3-Med Low
      3: P4-Low      
    on_value: #store lat value so it can be restored on power/boot up
      - lambda: id(power_select_lastvalue) = i;

  # - platform: "tuya"
  #   tuya_id: "${location}"
  #   name: "Power_SelectX"
  #   id: power_selectx
  #   enum_datapoint: 4
  #   options:
  #     0: P1-High
  #     1: P2-Med High
  #     2: P3-Med Low
  #     3: P4-Low      
  #   on_value:
  #     - lambda: id(power_select_lastvalue) = i;      
#
  - platform: "tuya"
    tuya_id: "${location}"
    name: "${location} ECO Select"
    id: eco_mode
    enum_datapoint: 101
    options:
      0: ECO1 - Heat then OFF
      1: ECO2 - Px then P4
#
# Data points observed in Tuya iOT platform during debug mode
# 1 - Power on (Heat)
#4 - Mode P1/P2/P3P4
#101 - ECO1/ECO2
#104 - Error Code
#105 - unused
#106 - Set Temp
#107 - Current Temp
#108 - Pipe Temp
#109 - Protect Temp
#-----------------
#Datapoint 1: switch (value: OFF)
#Datapoint 105: enum (value: 0)
#Datapoint 4: enum (value: 0)
#Datapoint 101: enum (value: 0)
#Datapoint 106: int value (value: 68)
#Datapoint 107: int value (value: 64)
#Datapoint 108: int value (value: 68)
#Datapoint 109: int value (value: 72)
#Datapoint 104: bitmask (value: 0)
#
# Register the Tuya MCU connection
tuya:
  id: "${location}"
  uart_id: tywe1s_uart
#
switch:
#This sends the Auger signal to the optoisolator to turn on the Auger motor    
  - platform: gpio
    pin: GPIO25 #this pin remains high at bootup and reset, no extra pellets disbursed
    name: "${location} AugerOut to optoisolator +LED"
    id: auger_output_to_optoisolator  
    inverted: yes    
#FAILSAFE. IF AUGER GETS STUCK on for over 5s, TURN IT OFF
    on_turn_on:
      - delay: 5s
      - switch.turn_off: auger_output_to_optoisolator
#
#wire the time LED on front panel to GPIO1 to indicate when new P5 level is on       
  - platform: gpio
    pin: GPIO19 #use 470ohm resistor in line w led
    name: "${location} P5 indicator LED"
    inverted: yes
    id: p5_indicator
#                    
# automate resetting stove errors using this button
  - platform: gpio
    pin: GPIO26
    name: "${location} Thumbsup RESET"
    inverted: yes
    id: thumbsup
    on_turn_on:
      - delay: 3.5s #hold time needed to reset error on display
      - switch.turn_off: thumbsup   
#
climate:
  - platform: tuya
    reports_fahrenheit: true # bug in stove requires this new flag.
    name: "${location} Wood Pellet Stove"
    id: tuya_climate
    switch_datapoint: 1
    target_temperature_datapoint: 106
    current_temperature_datapoint: 107
    visual:
      min_temperature: 15.5 #celcius
      max_temperature: 23
      temperature_step: 1

ota:
wifi:
#  use_address: 192.168.1.xxx # use when renaming this node
  ssid: "Van Slyke"
  password: !secret wifi_password
  power_save_mode: none
  use_address: 192.168.1.192
  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "${location}-Wood-Pellet-Stove"
    password: !secret wifi_password
#
logger:
  level: debug
  baud_rate: 0 #required for UART sniffer to work
debug:
  update_interval: 60s      