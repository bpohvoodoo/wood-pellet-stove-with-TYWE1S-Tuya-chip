#----------------------------------------------------------
# TUYA WOOD PELLET STOVE Converted to ESP32
# Version 3.2 by BPoHVoodoo
# cleaned up code,
# changed to use °C instead of Fahrenheit
# added WebServer
# version; 3.1.0
# changed to use with Nemaxx Px, added WebServer
# date: 04-10-23 bug fixes
# 3.0 converted to ESP32, added realtime exhaust sensor
# 2.0 added fire stoking function
# 1.0.0 added a Power Level P5 (ultra low power) that is fully configurable while in ECO2 mode.
# 1.1.0 added echo of actual display messages and status via Display's MCU UART monitoring
#
# All of these mods give a new "Ultra Low" power level which turns down the heat during IDLE mode so the stove goes thru fewer (no)
# on/off/igniter cycles and just maintains a lower heat output (for smaller rooms)
# when the room cools enuf, ECO2 mode will kick back to "Heating" which
# turns off this new Ultra Low power level, then once the room temp is +2F above set temp, stove
# goes into "Idle" mode again and new Ultra Low is active again.  The cycle repeats and the stove stays lit.
# and room doesn't drastically heat up driving your wife nuts.
# These mods ***require*** replacing the Tuya chip with an ESP32 D1 Mini & some MCU control board and Display board mods.  
# See Github Discussions for complete details
#
# NOTE: I am NOT a career/pro programmer.  There is probably tons of opportunity to
# consolidate many of the if/then statements that check things into convoluted programmer-porn style 
# Lambda evaluations, but I hate writing and debugging Lambdas,
# so my code makes way more sense for the average person and is very easy to debug. 
# Your mileage may vary. 
# And, more inportant, it gets the job done!
#----------------------------------------
#
substitutions:
  device_name: "pellet-ofen"
  device_description: Pellet Ofen mit ESPHome auf Wemos D1 mini32
  friendly_name: Pellet-Ofen
  location: Irgendwo
  lighting_count: "45" #sets max number of dumps of pellets during lighting
  switch_lighting2heating: "60.0" # 60°C or 140.0 F  # exactly the point it switches from "lighting to heating"
  message_welcome: "Willkommen!"
  message_cleaning: "Reinigung"
  message_igniting: "Zuendung"
  message_stabilization: "Stabilisierung"
  message_cooling: "Abkuehlen"
  message_switchoff: "Ausschaltvorgang"
  message_goodbye: "Auf Wiedersehen!"
  message_eco2: "ECO2"
#----------------------------------------------------------
#
esp32:
  board: wemos_d1_mini32
# Enable logging
logger:
  level: debug
  baud_rate: 0 #required for UART sniffer to work
debug:
  update_interval: 60s
# Enable Home Assistant API
api:
  reboot_timeout: 60min # if we lose home assistant keep running for 60 mins
  encryption:
    key: !secret enc_key
#
ota:
  password: !secret ota_password
#
wifi:
  use_address: 192.168.123.52 # use when renaming this node
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  power_save_mode: none
  reboot_timeout: 30min
  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "${location}-${friendly_name}"
    password: !secret wifi_password
#
captive_portal:
# Example configuration entry
web_server:
  port: 80
  include_internal: true
  local: true
  auth:
    username: !secret web_server_username
    password: !secret web_server_password
#
globals:
  - id: auger_count_global
    type: int
    restore_value: no
    initial_value: '0'
  - id: stoking_flag_global
    type: bool
    initial_value: "false"
    restore_value: yes
  - id: p5_flag_global
    type: bool
    initial_value: "false"
    restore_value: yes
  - id: DisRaw_global
    type: char
    restore_value: yes
  - id: DisRaw_lastvalue_global
    type: char
    restore_value: yes
  - id: power_select_lastvalue_global
    type: int
    restore_value: yes
  - id: set_temp_lastvalue_global
    type: int
    restore_value: no
#
uart: # define 3 hardware UARTS, 1 for TuyaMCU, others for MCU Display & temps monitoring
  - id: tywe1s_uart # communication from TuyaMCU to tywe1s chip UART1
    rx_pin: RX # Receives data from MCU, RX label on ESP32
    tx_pin: TX # Transmits data to MCU, TX label on ESP32
    baud_rate: 9600
  - id: mcu_uart_TXpin # Display message decoding UART2
    rx_pin: GPIO16 # attach new wire to TX labled pin on DISPLAY board
    baud_rate: 2400
    rx_buffer_size: 80
    debug:
      direction: RX
      dummy_receiver: true
      after:
        delimiter: [0xCC, 0x33]
      sequence:
        #- logger.log: "DIS"
        - lambda: |-
            UARTDebug::log_hex(direction, bytes, ' ');
            if (bytes.size()==5) { //Some packets have 5 bytes  
              if(bytes[0]==0xAA && bytes[1]==0x00 && bytes[2]!=0x4B) {
                if(bytes[2]==0x20 || bytes[2]==0x62 || bytes[2]==0x63 || bytes[2]==0x65 || bytes[2]==0x66 || bytes[2]==0x69 || bytes[2]==0x6A) {
                  id(DisRaw_lastvalue_global)=id(DisRaw_global);
                  id(DisRaw_global) = bytes[2];
                  id(DisplayText).execute();
                } else {
                  id(DISrawHEX).publish_state(str_sprintf("0x%02X",bytes[2]));
                }         
              }
            } else if (bytes.size()==6 && bytes[0]==0xAA && bytes[1]==0x01) { //Some packets have 6 bytes
              if(bytes[2]==0x46 && bytes[3]==0x02) { //Welcome to use
                id(DisRaw_lastvalue_global)=id(DisRaw_global);
                id(DisRaw_global) = bytes[3];
                id(DisplayText).execute();
              } else if(bytes[2]==0x49 && bytes[3]==0x80) { //Stabilization
                id(DisRaw_lastvalue_global)=id(DisRaw_global);
                id(DisRaw_global) = bytes[3];
                id(DisplayText).execute();
              } else if(bytes[2]==0x49 && bytes[3]==0x81) { //ECO2
                id(DisRaw_lastvalue_global)=id(DisRaw_global);
                id(DisRaw_global) = bytes[3];
                id(DisplayText).execute();
              //}else if(bytes[2]==0x49 && bytes[3]==0x01) {
              //  id(DISrawString).publish_state("ECO2");
              //}else if(bytes[2]==0x48 && bytes[3]==0x80) {
              //  id(DISrawString).publish_state("ECO1");
              //}else if(bytes[2]==0x48 && bytes[3]==0xC0) {
              //  id(DISrawString).publish_state("ECO2");
              //}else if(bytes[2]==0x48 && bytes[3]==0x83) {
              //  id(DISrawString).publish_state("ECO1");
              //}else if(bytes[2]==0x48 && bytes[3]==0xC3) {
              //  id(DISrawString).publish_state("ECO2");
              }
            }
#
  - id: mcu_uart_RXpin # from Display control board RX pin to MCU board RX pin UART3 gives us real time temps in middle byte
    rx_pin: GPIO21 #attach new wire to RX labled pin on DISPLAY board
    baud_rate: 2400
    rx_buffer_size: 80
    debug:
      direction: RX
      dummy_receiver: true
      after:
        delimiter: [0xCC, 0x33]
      sequence:
        #- logger.log: "MCU"
        - lambda: |-
            UARTDebug::log_hex(direction, bytes, ' '); 
            if (bytes.size()==10) {
              //id(current_temp_uart).publish_state((bytes[5])-20); //Celsius
              id(pipe_temp_uart).publish_state((bytes[6])-20); //Celsius
              //id(protect_temp_uart).publish_state((bytes[7])-20); //Celsius
            }
#
script:
  - id: auger_p5 # SCRIPT New P5 Power level Auger motor control, Started by the following events p5z, on_boot, DISrawString
    mode: single
    then:
      - logger.log: "1script.auger_p5.STARTING"
      - while: #Main loop
          condition:
            and:
            - binary_sensor.is_on: p5z #Power Level 5 is activated
            - text_sensor.state: #Stove is idling in ECO2 mode
                id: hvac_action_tuya
                state: 'IDLE'
            - lambda: return id(DisRaw_global) == 0x81;
            - sensor.in_range: #**** Stove is burning, exhaust is hot
                id: pipe_temp_uart
                above: ${switch_lighting2heating}
            # equal or above setpoint
            - lambda: return id(current_temp).state >= id(set_temp).state;
          then:
            - if:
                condition:
                  - binary_sensor.is_off: stoking_flag #we aren't stoking the fire
                then:
                  - switch.turn_on: auger_output
                  - delay: !lambda "return id(auger_on_time).state * 1000;"
                  - switch.turn_off: auger_output  
                  - delay: !lambda "return id(auger_off_time).state * 1000;"
                else:
                  - logger.log:
                      format: "SCRIPT.Stoking FIRE NOW | stoking_temp= %f"
                      args: ['id(stoking_temp).state']
                  - switch.turn_on: auger_output
                  - delay: !lambda "return id(stoking_on_time).state * 1000;" # SECONDS ON
                  - switch.turn_off: auger_output
                  - delay: !lambda "return id(stoking_off_time).state * 1000;" # SECONDS OFF
#
  - id: DisplayText # SCRIPT New P5 Power level Auger motor control, Started by the following events p5z, on_boot, DISrawString
    mode: single
    then:
      - lambda: |-
                id(DISrawHEX).publish_state(str_sprintf("0x%02X",id(DisRaw_global)));
                switch (id(DisRaw_global)) {
                  case 0x02:
                    id(DISrawString).publish_state("${message_welcome}");
                    break;
                  case 0x20:
                    id(DISrawString).publish_state("${message_welcome}");
                    break;
                  case 0x62:
                    id(DISrawString).publish_state("${message_switchoff}");
                    break;
                  case 0x63:
                    id(DISrawString).publish_state("${message_cleaning}");
                    break;
                  case 0x65:
                    id(DISrawString).publish_state("${message_igniting}");
                    break;
                  case 0x66:
                    id(DISrawString).publish_state("${message_stabilization}");
                    break;
                  case 0x69:
                    id(DISrawString).publish_state("${message_cooling}");
                    break;
                  case 0x6A:
                    id(DISrawString).publish_state("${message_goodbye}");
                    break;
                  case 0x6C:
                    id(DISrawString).publish_state("${message_cleaning}");
                    break;
                  case 0x80:
                    id(DISrawString).publish_state("${message_stabilization}");
                    break;
                  case 0x81:
                    id(DISrawString).publish_state("${message_eco2}");
                    break;
                  default:
                    break;
                }
#
binary_sensor:
  - platform: "tuya"
    id: stove_on
    name: "${location} Stove-Power On"
    sensor_datapoint: 1
#
  - platform: template # template sensors expose sensors to HA
    name: ${location} Stove Stoke Fire Flag
    id: stoking_flag
    # set it to the value of the global
    lambda: return id(stoking_flag_global) == 1;
#
  - platform: template # template sensors expose sensors to HA
    name: ${location} Stove P5 active Flag
    id: p5_flag
    # set it to the value of the global
    lambda: return id(p5_flag_global) == 1;
#
  - platform: homeassistant
    id: p5z #read new P5 power mode from home assistant, toggle repurposed Timer LED on display module 
    entity_id: input_boolean.${location}_stove_p5
    on_state:      
      then:
        - if:
            condition:
              - binary_sensor.is_on: p5z #p5 is  active
            then:
              - switch.turn_on: p5_indicator
            else: 
              - switch.turn_off: p5_indicator
#
  - platform: gpio # MCU CONTROL BOARD AUGER SENSOR
    pin: GPIO27  # input only pin
    internal: true # this is just a flag you expose and watch in Lovelace
    id: ${location}_stove_auger_input
    name: "${location} Stove Auger Input" #Auger signal from MCU, goes low when Auger motor is running
    filters:
      - invert #flip it
    on_state: 
      then: 
        - if: # LIGHTING, ECHO Auger
            condition:
              - lambda: return id(DisRaw_global) == 0x65;
            then:
              - if:
                  condition:
                    and:
                      - binary_sensor.is_on: ${location}_stove_auger_input
                      #limit pellets in hopper on lighting. it only needs 35 turns to actually light. Adjust this value if stove repeatedly fails to light every other time.
                      - lambda: return id(auger_count_global) <= ${lighting_count}; 
                          
                  then:
                    - switch.turn_on: auger_output
                    - lambda: id(auger_count_global) += 1; #keep track of how many auger turns happen and reset if stove lights
                    - lambda: id(auger_counter).publish_state(id(auger_count_global)); #publish it to the sensor
                  else: #TURN OFF - LIGHTING, echo Auger
                     switch.turn_off: auger_output
            else:
              - if:
                  condition: 
                    - sensor.in_range: 
                        id: pipe_temp_uart
                        above: ${switch_lighting2heating} #stove is lit. reset counter                      
                  then:
                    - if:
                        condition:
                          - lambda: return id(auger_count_global) > 0;
                        then:      
                            - lambda: id(auger_count_global) = 0;
                            - lambda: id(auger_counter).publish_state(id(auger_count_global));
        - if: # REGULAR ECHO OF AUGER
            condition:
              or:
                - binary_sensor.is_off: p5z # NOT In power level 5
                - lambda: return id(DisRaw_global) != 0x81; # NOT in ECO2
                - lambda: return !(id(auger_p5).is_running());
            then:
              - if:
                  condition:
                    - binary_sensor.is_on: ${location}_stove_auger_input
                  then:
                    - switch.turn_on: auger_output
                  else:
                    - switch.turn_off: auger_output

button:
  - platform: restart #allows remote reset of tywe1s chip from home assistant or internally
    id: restart_esp
    name: "${location} Stove Restart"
#
  - platform: safe_mode # required to upload firmware if were low on memory. put chip in safe mode, reboot, then OTA upload new firmware.
    name: "${location} Stove SAFE Mode BUTTON"        
#
# DEFINE ALL SENSORS AND SWITCHES
#
text_sensor:
  - platform: debug
    device:
      name: "${location} Stove Device Info"
    reset_reason:
      name: "${location} Stove Reset Reason"
#
  - platform: template #from DISPLAY MCU in the display board, gives us what specific text is shown on the display
    id: DISrawHEX
    name: ${location} Stove Display HEX Sensor
#   
  - platform: template #from MCU in the display board, gives us what specific text is shown on the display
    id: DISrawString
    name: ${location} Stove Display Text Sensor
#
  - platform: template
    name: "${location} Stove Uptime"
    lambda: |-
      uint32_t dur = id(uptime_s).state;
      int dys = dur / 86400;
      dur %= 86400;
      int hrs = dur / 3600;
      dur %= 3600;
      int mnts = dur / 60;
      dur %= 60;
      return str_sprintf("%ud %02uh %02um %02us", dys, hrs, mnts, dur);
    icon: mdi:clock-start
    update_interval: 30s
#
  - platform: template #This sensor is changing all the time and the ONLY indicator of what state the stove is in
    id: hvac_action_tuya
    name: "${location} Stove HVAC action Tuya"
    lambda: |-
      switch (id(tuya_climate).action) {
        case CLIMATE_ACTION_OFF:
          return (std::string) "OFF";
          break;
        case CLIMATE_ACTION_HEATING:
          return (std::string) "HEATING";
          break;
        case CLIMATE_ACTION_IDLE:
          return (std::string) "IDLE";
          break;
        default:
          return (std::string) "UNKNOWN";
          break;
      }
    on_value: #this sensor changes from HEATING to IDLE in ECO2 mode or when we reach set temp in ECO1.
      - if:
          condition:
            - binary_sensor.is_off: stove_on
          then: 
            #- lambda: id(DISrawString).publish_state("Auf Wiedersehen!"); 
#
i2c: # For time of flight sensor
  sda: 5
  scl: 33
#
sensor:    
  - platform: wifi_signal
    name: "${location} Stove WiFi Signal db"
    update_interval: 30s 
    id: wifi_signal_db 
#
  - platform: copy # Reports the WiFi signal strength in %
    source_id: wifi_signal_db
    name: "${location} Stove WiFi Signal %"
    filters:
      - lambda: return min(max(2 * (x + 100.0), 0.0), 100.0);
    unit_of_measurement: "Signal %"
    entity_category: "diagnostic"
#
  - platform: debug
    free:
      name: "${location} Stove Heap Free"
#
#  - platform: template
#    id: current_temp_uart
#    unit_of_measurement: "°C"
#    name: "${location} Stove UART Current Temp"
#
  - platform: template #THIS SHOULD ONLY CONTROL STOKING OR NOT
    id: pipe_temp_uart
    unit_of_measurement: "°C"
    name: "${location} Stove UART Pipe Temp"
#
  #- platform: template
  # id: protect_temp_uart
  #  unit_of_measurement: "°C"
  #  name: "${location} Stove UART Protect Temp"
#
  - platform: template
    name: ${location} Stove-Auger Counter (Lighting)
    id: auger_counter
#get these object values from home assistant 
  - platform: homeassistant
    id: auger_off_time
    entity_id: input_number.${location}_stove_auger_off_time #helper in home assistant
#
  - platform: homeassistant
    id: auger_on_time
    entity_id: input_number.${location}_stove_auger_on_time #helper in home assistant
#    
  - platform: homeassistant
    id: stoking_temp
    entity_id: input_number.${location}_stove_stoking_temp #helper in home assistant
    force_update: true
#
  - platform: homeassistant
    id: stoking_on_time
    entity_id: input_number.${location}_stove_stoking_on_time #helper in home assistant
    force_update: true
#
  - platform: homeassistant
    id: stoking_off_time
    entity_id: input_number.${location}_stove_stoking_off_time #helper in home assistant
    force_update: true
#    
  - platform: vl53l0x
    name: "${location} Stove-RAW Pellet Level"
    address: 0x29
    long_range: true
    timeout: 200us
    update_interval: 10s
    unit_of_measurement: "m"
    accuracy_decimals: 2
    on_value:
      then:
        - sensor.template.publish:
            id: ultrasonic_smoothed
            state: !lambda 'return ((0.47-(x-0.03))*(100/0.47));' # Replace 0.4 by the height of hopper. From the sensor to the bottom.
                                                                  # Website to know how to multiply values :https://www.skillsyouneed.com/num/percent-change.html 
#
  - platform: template
    id: ultrasonic_smoothed
    update_interval: 30s
    accuracy_decimals: 0
    unit_of_measurement: "%"
    icon: "mdi:sack-percent"
    name: "${location} Stove-Pellet Level"
    filters:
      - sliding_window_moving_average:
          window_size: 60
          send_every: 15
#
  - platform: "tuya"
    id: error_code
    name: "${location} Stove-Error Code"
    sensor_datapoint: 104
#
  - platform: "tuya"
    id: power_mode
    name: "${location} Stove-Power Mode"
    sensor_datapoint: 4
#
  - platform: "tuya"
    id: set_temp
    name: "${location} Stove-Set Temp"
    unit_of_measurement: "°C"
    sensor_datapoint: 2
#
  - platform: "tuya"
    id: current_temp
    name: "${location} Stove-Current Temp"
    unit_of_measurement: "°C"
    sensor_datapoint: 3
    filters:
    - exponential_moving_average: #this sensor is NOISY!
        alpha: 0.7
#
  - platform: "tuya"
    id: pipe_temp
    name: "${location} Stove-Pipe Temp"
    unit_of_measurement: "°C"
    sensor_datapoint: 102
#
  - platform: "tuya"
    id: protect_temp
    name: "${location} Stove-Protect Temp"
    unit_of_measurement: "°C"
    sensor_datapoint: 103
#
  - platform: uptime
    internal: true
    id: uptime_s
    update_interval: 10s
#
#DEFINE SELECTS
#
select:
  - platform: "tuya"
    tuya_id: "${location}"
    name: "${location} Stove Power Select"
    id: power_select
    enum_datapoint: 4
    options:
      0: P1-Hoch
      1: P2-Mittelhoch
      2: P3-Mittel
      3: P4-Niedrig    
    on_value: #store last value so it can be restored on power/boot up
      then:
        - lambda: id(power_select_lastvalue_global) = i;
#
  - platform: "tuya"
    tuya_id: "${location}"
    name: "${location} Stove ECO Select"
    id: eco_mode
    enum_datapoint: 101
    options:
      0: ECO1 - Heizen dann AUS
      1: ECO2 - Heizen dann P4
    on_value:
        then:
          - lambda: id(set_temp_lastvalue_global) = id(set_temp).state;
          - logger.log:
              format: "set_temp_lastvalue= %i"
              args: ['id(set_temp_lastvalue_global)']
        #- climate.control:
        #    id: tuya_climate
        #    target_temperature: 25
        #- climate.control:
        #    id: tuya_climate
        #    target_temperature: 20
#
# Data points observed in Tuya iOT platform during debug mode
#1 - Power on (Heat)
#2 - Set Temp
#3 - Current Temp
#4 - Mode P1/P2/P3P4
#101 - ECO1/ECO2
#102 - Pipe Temp
#103 - Protect Temp
#104 - Error Code

#-----------------
#Datapoint 1: switch (value: ON)
#Datapoint 2: int value (value: 20) in °C
#Datapoint 3: int value (value: 19) in °C
#Datapoint 4: enum (value: 2)
#Datapoint 101: enum (value: 0)
#Datapoint 102: int value (value: 123) in °C
#Datapoint 103: int value (value: 25) in °C
#Datapoint 104: bitmask (value: 0)
#GPIO Configuration: status: pin 5, reset: pin 0
#Product: 'k5dWTKaI3Z9llDEA1.0.0'
#
# Register the Tuya MCU connection
tuya:
  id: "${location}"
  uart_id: tywe1s_uart
#
switch:
  - platform: gpio #This sends the Auger signal to the optoisolator to turn on the Auger motor
    internal: true
    name: "${location} Stove Auger Output"
    pin: GPIO25 #this pin remains high at bootup and reset, no extra pellets disbursed
    inverted: yes
    id: auger_output
    on_turn_on: #FAILSAFE. IF AUGER EVER GETS STUCK on for over 5s, TURN IT OFF
      - delay: 5s
      - switch.turn_off: auger_output
#
  - platform: gpio #wire the time LED on front panel to GPIO1 to indicate when new P5 level is on
    pin: GPIO19
    inverted: yes
    id: p5_indicator
    internal: true
#
  - platform: gpio # automate resetting stove errors using this button
    name: "${location} Stove Thumbsup RESET"
    pin: GPIO26
    inverted: yes
    id: thumbsup
    on_turn_on:
      - delay: 3.5s #hold time needed to reset error on display
      - switch.turn_off: thumbsup
#
climate:
  - platform: tuya
    reports_fahrenheit: false # bug in stove requires this new flag.
    name: "${location} Stove"
    id: tuya_climate
    switch_datapoint: 1
    target_temperature_datapoint: 2
    current_temperature_datapoint: 3
    visual:
      min_temperature: 10.0 #celcius
      max_temperature: 25.0
      temperature_step: 1
#
esphome:  
  name: ${device_name}
  platformio_options:
    upload_speed: 115200 
    board_build.extra_flags: # REQUIRED FOR UART TO WORK
      - "-DARDUINO_USB_CDC_ON_BOOT=0"  # Override, defaults to '-DARDUINO_USB_CDC_ON_BOOT=1'
  comment: ${device_description}
  on_boot:
    priority: -100
    then:
      #- switch.turn_off: auger_output
      #- delay: 5s
      - switch.turn_off: auger_output
      - lambda: id(DISrawString).publish_state("Booting ESP... warte 20s");
      - delay: 20s
      - logger.log: "Now executing on_boot. 20s delay over, STARTING UP"
      #- switch.turn_off: auger_output
      - select.set_index:
          id: power_select
          index: !lambda return id(power_select_lastvalue_global); # set to saved flash value
      - lambda: |- # initially publish some values to the sensor
                id(auger_counter).publish_state(id(auger_count_global)); // initially publish it to the sensor
                id(DISrawString).publish_state("Status unbekannt");
      - script.execute: DisplayText
      - if:
          condition:
            - binary_sensor.is_off: stove_on
          then:
            - lambda: |-
                      id(DISrawString).publish_state("Auf Wiedersehen!");
          else:
            - if:
                condition:
                  and:
                  - text_sensor.state: #Stove HEATING not IDLING
                      id: hvac_action_tuya
                      state: 'HEATING'
                then:
                  - if:
                      condition:
                        - sensor.in_range: #stove is lit
                            id: pipe_temp_uart
                            above: ${switch_lighting2heating}
                      then:
                        - lambda: id(DISrawString).publish_state("Stabilisierung");
                      else:
                        - lambda: id(DISrawString).publish_state("Zuendung");
                        #- lambda: id(DISrawString).publish_state("Reinigung");
      - if:
          condition: 
            and:
            - binary_sensor.is_on: p5z
          then:
            - switch.turn_on: p5_indicator
          else:  
            - switch.turn_off: p5_indicator
  on_shutdown: 
    priority: 1000
    then:
    - switch.turn_off: auger_output
  on_loop:
    - if:
        condition:
          and:
            - binary_sensor.is_on: stove_on
            - binary_sensor.is_on: p5z
            - lambda: return id(DisRaw_global) == 0x81;
            - text_sensor.state: #Stove is idling in ECO2 mode
                id: hvac_action_tuya
                state: 'IDLE'
            - sensor.in_range: #stove is lit
                id: pipe_temp_uart
                above: ${switch_lighting2heating}
            - lambda: return id(current_temp).state >= id(set_temp).state;
        then:
          - globals.set:
              id: p5_flag_global
              value: 'true'
          - if:
              condition:
                - lambda: return id(pipe_temp_uart).state < id(stoking_temp).state;
              then:
                - globals.set: #expose to ha
                    id: stoking_flag_global
                    value: 'true'
              else:
                - if:
                    condition:
                      - lambda: return id(pipe_temp_uart).state > id(stoking_temp).state;
                    then:
                      - globals.set: #expose to ha
                          id: stoking_flag_global
                          value: 'false'
          - if:
              condition:
                - lambda: return !(id(auger_p5).is_running());
              then:
                - logger.log: "Starting auger_p5"
                - script.execute: auger_p5
        else:
          - globals.set:
              id: stoking_flag_global
              value: 'false'
          - globals.set:
              id: p5_flag_global
              value: 'false'
          - script.stop: auger_p5